/**
 * Ninja Toolkit - Advanced Vulnerability Scanner
 * Comprehensive security vulnerability detection and analysis
 * Integrates CVE database, exploit references, and security best practices
 */

const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs').promises;
const path = require('path');
const net = require('net');
const tls = require('tls');
const https = require('https');
const crypto = require('crypto');

const execAsync = promisify(exec);

/**
 * Main Vulnerability Scanner Class
 */
class VulnerabilityScanner {
  constructor() {
    this.cveDatabase = null;
    this.exploitDatabase = null;
    this.owaspTop10 = this.initializeOWASPTop10();
    this.vulnerabilityCache = new Map();
    this.scanResults = [];
  }

  /**
   * Initialize OWASP Top 10 vulnerability patterns
   */
  initializeOWASPTop10() {
    return {
      A01_2021: {
        name: 'Broken Access Control',
        description: 'Restrictions on authenticated users not properly enforced',
        indicators: [
          'Missing authentication checks',
          'Insecure direct object references',
          'Path traversal vulnerabilities',
          'Missing CORS policies',
          'Elevation of privilege'
        ],
        severity: 'CRITICAL',
        cweIds: ['CWE-22', 'CWE-284', 'CWE-639']
      },
      A02_2021: {
        name: 'Cryptographic Failures',
        description: 'Failures related to cryptography leading to sensitive data exposure',
        indicators: [
          'Weak encryption algorithms',
          'Hardcoded secrets',
          'Unencrypted sensitive data',
          'Weak key generation',
          'Deprecated TLS versions'
        ],
        severity: 'HIGH',
        cweIds: ['CWE-259', 'CWE-327', 'CWE-326']
      },
      A03_2021: {
        name: 'Injection',
        description: 'Hostile data used to execute unintended commands',
        indicators: [
          'SQL injection points',
          'Command injection vectors',
          'LDAP injection',
          'XPath injection',
          'Template injection'
        ],
        severity: 'CRITICAL',
        cweIds: ['CWE-79', 'CWE-89', 'CWE-73']
      },
      A04_2021: {
        name: 'Insecure Design',
        description: 'Missing or ineffective control design',
        indicators: [
          'Missing rate limiting',
          'No security logging',
          'Inadequate input validation',
          'Missing threat modeling',
          'Insecure default configurations'
        ],
        severity: 'MEDIUM',
        cweIds: ['CWE-209', 'CWE-256', 'CWE-501']
      },
      A05_2021: {
        name: 'Security Misconfiguration',
        description: 'Missing hardening, excessive permissions, error handling revealing information',
        indicators: [
          'Default credentials',
          'Unnecessary features enabled',
          'Verbose error messages',
          'Missing security headers',
          'Outdated software components'
        ],
        severity: 'HIGH',
        cweIds: ['CWE-16', 'CWE-611', 'CWE-614']
      },
      A06_2021: {
        name: 'Vulnerable and Outdated Components',
        description: 'Using components with known vulnerabilities',
        indicators: [
          'Outdated libraries',
          'Unpatched frameworks',
          'EOL software versions',
          'Missing security updates',
          'Vulnerable dependencies'
        ],
        severity: 'HIGH',
        cweIds: ['CWE-1104', 'CWE-1395']
      },
      A07_2021: {
        name: 'Identification and Authentication Failures',
        description: 'Authentication and session management issues',
        indicators: [
          'Weak password policies',
          'Session fixation',
          'Missing MFA',
          'Credential stuffing vulnerability',
          'Insecure session management'
        ],
        severity: 'CRITICAL',
        cweIds: ['CWE-287', 'CWE-384', 'CWE-307']
      },
      A08_2021: {
        name: 'Software and Data Integrity Failures',
        description: 'Code and infrastructure not protected against integrity violations',
        indicators: [
          'Unsigned updates',
          'Insecure deserialization',
          'Untrusted CI/CD pipeline',
          'Missing integrity checks',
          'Auto-update without verification'
        ],
        severity: 'HIGH',
        cweIds: ['CWE-502', 'CWE-829', 'CWE-494']
      },
      A09_2021: {
        name: 'Security Logging and Monitoring Failures',
        description: 'Insufficient logging and monitoring',
        indicators: [
          'No audit logs',
          'Inadequate monitoring',
          'Missing alerting',
          'Log injection vulnerabilities',
          'Insufficient log retention'
        ],
        severity: 'MEDIUM',
        cweIds: ['CWE-778', 'CWE-117', 'CWE-223']
      },
      A10_2021: {
        name: 'Server-Side Request Forgery (SSRF)',
        description: 'Application fetches remote resource without validating URL',
        indicators: [
          'Unvalidated URL parameters',
          'Internal network access',
          'Metadata service access',
          'DNS rebinding vulnerability',
          'URL redirect without validation'
        ],
        severity: 'HIGH',
        cweIds: ['CWE-918']
      }
    };
  }

  /**
   * Load CVE database from local storage
   */
  async loadCVEDatabase() {
    try {
      const dbPath = path.join(__dirname, '../../config/cve-database.json');
      const data = await fs.readFile(dbPath, 'utf8');
      this.cveDatabase = JSON.parse(data);
      console.log(`Loaded ${this.cveDatabase.cves.length} CVE entries`);
      return true;
    } catch (error) {
      console.error('Failed to load CVE database:', error.message);
      this.cveDatabase = { cves: [], lastUpdated: new Date().toISOString() };
      return false;
    }
  }

  /**
   * Scan target for vulnerabilities
   */
  async scanTarget(target, options = {}) {
    const scanId = crypto.randomUUID();
    const startTime = Date.now();

    console.log(`Starting vulnerability scan ${scanId} for target: ${target}`);

    const results = {
      scanId,
      target,
      timestamp: new Date().toISOString(),
      scanType: options.scanType || 'comprehensive',
      vulnerabilities: [],
      summary: {
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        info: 0
      },
      recommendations: []
    };

    try {
      // Load CVE database if not already loaded
      if (!this.cveDatabase) {
        await this.loadCVEDatabase();
      }

      // Perform different scan types
      if (options.scanType === 'network' || options.scanType === 'comprehensive') {
        const networkVulns = await this.scanNetworkVulnerabilities(target);
        results.vulnerabilities.push(...networkVulns);
      }

      if (options.scanType === 'ssl' || options.scanType === 'comprehensive') {
        const sslVulns = await this.scanSSLTLSVulnerabilities(target);
        results.vulnerabilities.push(...sslVulns);
      }

      if (options.scanType === 'service' || options.scanType === 'comprehensive') {
        const serviceVulns = await this.scanServiceVulnerabilities(target);
        results.vulnerabilities.push(...serviceVulns);
      }

      if (options.scanType === 'web' || options.scanType === 'comprehensive') {
        const webVulns = await this.scanWebVulnerabilities(target);
        results.vulnerabilities.push(...webVulns);
      }

      if (options.scanType === 'config' || options.scanType === 'comprehensive') {
        const configVulns = await this.scanConfigurationVulnerabilities(target);
        results.vulnerabilities.push(...configVulns);
      }

      // Calculate summary statistics
      results.vulnerabilities.forEach(vuln => {
        const severity = vuln.severity.toLowerCase();
        if (results.summary[severity] !== undefined) {
          results.summary[severity]++;
        }
      });

      // Generate recommendations
      results.recommendations = this.generateRecommendations(results.vulnerabilities);

      // Calculate scan duration
      results.duration = Date.now() - startTime;

      this.scanResults.push(results);
      return results;

    } catch (error) {
      console.error('Vulnerability scan failed:', error);
      results.error = error.message;
      return results;
    }
  }

  /**
   * Scan for network-level vulnerabilities
   */
  async scanNetworkVulnerabilities(target) {
    const vulnerabilities = [];

    try {
      // Check for open ports with known vulnerabilities
      const commonPorts = [
        { port: 21, service: 'FTP', vulns: ['Anonymous access', 'Clear-text credentials'] },
        { port: 22, service: 'SSH', vulns: ['Weak key exchange', 'Outdated version'] },
        { port: 23, service: 'Telnet', vulns: ['Unencrypted communication', 'No authentication'] },
        { port: 25, service: 'SMTP', vulns: ['Open relay', 'No encryption'] },
        { port: 80, service: 'HTTP', vulns: ['Unencrypted traffic', 'Missing security headers'] },
        { port: 443, service: 'HTTPS', vulns: ['Weak cipher suites', 'Certificate issues'] },
        { port: 445, service: 'SMB', vulns: ['EternalBlue', 'SMBv1 enabled'] },
        { port: 1433, service: 'MSSQL', vulns: ['SQL injection', 'Weak authentication'] },
        { port: 3306, service: 'MySQL', vulns: ['Default credentials', 'Remote access'] },
        { port: 3389, service: 'RDP', vulns: ['BlueKeep', 'Weak credentials'] },
        { port: 5432, service: 'PostgreSQL', vulns: ['SQL injection', 'Privilege escalation'] },
        { port: 5900, service: 'VNC', vulns: ['Weak authentication', 'Unencrypted'] },
        { port: 6379, service: 'Redis', vulns: ['No authentication', 'Command injection'] },
        { port: 8080, service: 'HTTP-Alt', vulns: ['Exposed admin panel', 'Default credentials'] },
        { port: 27017, service: 'MongoDB', vulns: ['No authentication', 'Remote access'] }
      ];

      for (const portInfo of commonPorts) {
        const isOpen = await this.checkPort(target, portInfo.port);
        if (isOpen) {
          // Port is open, check for specific vulnerabilities
          vulnerabilities.push({
            id: `NET-${portInfo.port}-001`,
            type: 'network',
            severity: portInfo.port === 23 || portInfo.port === 21 ? 'HIGH' : 'MEDIUM',
            title: `${portInfo.service} Service Exposed`,
            description: `Port ${portInfo.port} (${portInfo.service}) is accessible from external networks`,
            port: portInfo.port,
            service: portInfo.service,
            impact: 'Potential attack surface for exploitation',
            recommendation: `Review necessity of ${portInfo.service} exposure and implement firewall rules`,
            references: [],
            potentialVulnerabilities: portInfo.vulns
          });

          // Check for service-specific CVEs
          const serviceCVEs = this.searchCVEsByService(portInfo.service);
          if (serviceCVEs.length > 0) {
            serviceCVEs.slice(0, 3).forEach(cve => {
              vulnerabilities.push({
                id: cve.id,
                type: 'cve',
                severity: cve.severity,
                title: cve.title,
                description: cve.description,
                port: portInfo.port,
                service: portInfo.service,
                cvssScore: cve.cvssScore,
                impact: cve.impact,
                recommendation: cve.recommendation,
                references: cve.references
              });
            });
          }
        }
      }

      // Check for firewall misconfigurations
      const firewallVuln = await this.checkFirewallConfiguration(target);
      if (firewallVuln) {
        vulnerabilities.push(firewallVuln);
      }

    } catch (error) {
      console.error('Network vulnerability scan error:', error);
    }

    return vulnerabilities;
  }

  /**
   * Check if a port is open
   */
  async checkPort(host, port, timeout = 2000) {
    return new Promise((resolve) => {
      const socket = new net.Socket();

      socket.setTimeout(timeout);

      socket.on('connect', () => {
        socket.destroy();
        resolve(true);
      });

      socket.on('timeout', () => {
        socket.destroy();
        resolve(false);
      });

      socket.on('error', () => {
        resolve(false);
      });

      socket.connect(port, host);
    });
  }

  /**
   * Scan for SSL/TLS vulnerabilities
   */
  async scanSSLTLSVulnerabilities(target) {
    const vulnerabilities = [];

    try {
      const sslInfo = await this.getSSLInfo(target, 443);

      // Check for weak protocols
      if (sslInfo.protocol === 'TLSv1' || sslInfo.protocol === 'TLSv1.1' ||
          sslInfo.protocol === 'SSLv3' || sslInfo.protocol === 'SSLv2') {
        vulnerabilities.push({
          id: 'SSL-001',
          type: 'ssl',
          severity: 'HIGH',
          title: 'Weak SSL/TLS Protocol Version',
          description: `Server supports deprecated protocol ${sslInfo.protocol}`,
          impact: 'Vulnerable to POODLE, BEAST, and other protocol-level attacks',
          recommendation: 'Disable SSLv2, SSLv3, TLSv1.0, and TLSv1.1. Use TLSv1.2 or higher',
          references: [
            'CVE-2014-3566 (POODLE)',
            'CVE-2011-3389 (BEAST)',
            'https://www.ssllabs.com/ssltest/'
          ]
        });
      }

      // Check for weak cipher suites
      if (sslInfo.ciphers) {
        const weakCiphers = this.identifyWeakCiphers(sslInfo.ciphers);
        if (weakCiphers.length > 0) {
          vulnerabilities.push({
            id: 'SSL-002',
            type: 'ssl',
            severity: 'MEDIUM',
            title: 'Weak Cipher Suites Enabled',
            description: `Server supports weak cipher suites: ${weakCiphers.join(', ')}`,
            impact: 'Vulnerable to cryptographic attacks and man-in-the-middle attacks',
            recommendation: 'Configure server to use only strong cipher suites (AES-GCM, ChaCha20)',
            references: [
              'https://ciphersuite.info/',
              'https://mozilla.github.io/server-side-tls/ssl-config-generator/'
            ]
          });
        }
      }

      // Check certificate validity
      if (sslInfo.certificate) {
        const certVulns = this.analyzeCertificate(sslInfo.certificate);
        vulnerabilities.push(...certVulns);
      }

      // Check for specific SSL/TLS vulnerabilities
      const tlsVulnerabilities = [
        {
          id: 'SSL-003',
          name: 'Heartbleed',
          cve: 'CVE-2014-0160',
          check: async () => this.checkHeartbleed(target)
        },
        {
          id: 'SSL-004',
          name: 'DROWN',
          cve: 'CVE-2016-0800',
          check: async () => this.checkDROWN(target)
        },
        {
          id: 'SSL-005',
          name: 'FREAK',
          cve: 'CVE-2015-0204',
          check: async () => this.checkFREAK(target)
        },
        {
          id: 'SSL-006',
          name: 'Logjam',
          cve: 'CVE-2015-4000',
          check: async () => this.checkLogjam(target)
        }
      ];

      for (const vulnCheck of tlsVulnerabilities) {
        const isVulnerable = await vulnCheck.check();
        if (isVulnerable) {
          vulnerabilities.push({
            id: vulnCheck.id,
            type: 'ssl',
            severity: 'CRITICAL',
            title: `${vulnCheck.name} Vulnerability Detected`,
            description: `Server is vulnerable to ${vulnCheck.name} attack (${vulnCheck.cve})`,
            impact: 'Sensitive data exposure, session hijacking, decryption of traffic',
            recommendation: 'Update OpenSSL/TLS library and reconfigure server',
            references: [`https://nvd.nist.gov/vuln/detail/${vulnCheck.cve}`]
          });
        }
      }

    } catch (error) {
      console.error('SSL/TLS vulnerability scan error:', error);
    }

    return vulnerabilities;
  }

  /**
   * Get SSL/TLS information for a host
   */
  async getSSLInfo(host, port = 443) {
    return new Promise((resolve) => {
      const options = {
        host,
        port,
        rejectUnauthorized: false,
        agent: false
      };

      const socket = tls.connect(options, () => {
        const info = {
          protocol: socket.getProtocol(),
          cipher: socket.getCipher(),
          certificate: socket.getPeerCertificate(true),
          authorized: socket.authorized,
          authorizationError: socket.authorizationError
        };
        socket.end();
        resolve(info);
      });

      socket.on('error', (error) => {
        resolve({ error: error.message });
      });

      socket.setTimeout(5000, () => {
        socket.destroy();
        resolve({ error: 'Timeout' });
      });
    });
  }

  /**
   * Identify weak cipher suites
   */
  identifyWeakCiphers(cipher) {
    const weakCiphers = [];
    const cipherName = cipher.name || '';

    const weakPatterns = [
      'DES', 'RC4', 'MD5', 'NULL', 'EXPORT', 'anon',
      'ADH', 'AECDH', 'PSK', 'SRP', 'KRB5'
    ];

    for (const pattern of weakPatterns) {
      if (cipherName.includes(pattern)) {
        weakCiphers.push(cipherName);
        break;
      }
    }

    return weakCiphers;
  }

  /**
   * Analyze SSL certificate for issues
   */
  analyzeCertificate(cert) {
    const vulnerabilities = [];

    if (!cert || typeof cert !== 'object') {
      return vulnerabilities;
    }

    // Check certificate expiration
    if (cert.valid_to) {
      const expiryDate = new Date(cert.valid_to);
      const daysUntilExpiry = Math.floor((expiryDate - new Date()) / (1000 * 60 * 60 * 24));

      if (daysUntilExpiry < 0) {
        vulnerabilities.push({
          id: 'CERT-001',
          type: 'certificate',
          severity: 'CRITICAL',
          title: 'Expired SSL Certificate',
          description: `Certificate expired ${Math.abs(daysUntilExpiry)} days ago`,
          impact: 'Browser warnings, user trust issues, potential MITM attacks',
          recommendation: 'Renew SSL certificate immediately'
        });
      } else if (daysUntilExpiry < 30) {
        vulnerabilities.push({
          id: 'CERT-002',
          type: 'certificate',
          severity: 'MEDIUM',
          title: 'SSL Certificate Expiring Soon',
          description: `Certificate expires in ${daysUntilExpiry} days`,
          impact: 'Service disruption if not renewed',
          recommendation: 'Renew SSL certificate before expiration'
        });
      }
    }

    // Check for self-signed certificate
    if (cert.issuer && cert.subject) {
      if (JSON.stringify(cert.issuer) === JSON.stringify(cert.subject)) {
        vulnerabilities.push({
          id: 'CERT-003',
          type: 'certificate',
          severity: 'HIGH',
          title: 'Self-Signed Certificate',
          description: 'Server uses a self-signed certificate',
          impact: 'Browser warnings, lack of trust validation, potential MITM attacks',
          recommendation: 'Obtain certificate from trusted Certificate Authority'
        });
      }
    }

    // Check signature algorithm
    if (cert.signatureAlgorithm) {
      const weakAlgorithms = ['sha1', 'md5', 'md2'];
      const algorithm = cert.signatureAlgorithm.toLowerCase();

      if (weakAlgorithms.some(weak => algorithm.includes(weak))) {
        vulnerabilities.push({
          id: 'CERT-004',
          type: 'certificate',
          severity: 'HIGH',
          title: 'Weak Certificate Signature Algorithm',
          description: `Certificate uses weak signature algorithm: ${cert.signatureAlgorithm}`,
          impact: 'Certificate forgery, collision attacks',
          recommendation: 'Reissue certificate with SHA-256 or stronger algorithm'
        });
      }
    }

    // Check key size
    if (cert.bits) {
      if (cert.bits < 2048) {
        vulnerabilities.push({
          id: 'CERT-005',
          type: 'certificate',
          severity: 'HIGH',
          title: 'Weak Certificate Key Size',
          description: `Certificate key size (${cert.bits} bits) is below recommended minimum`,
          impact: 'Vulnerable to brute force attacks',
          recommendation: 'Use at least 2048-bit RSA or 256-bit ECC keys'
        });
      }
    }

    return vulnerabilities;
  }

  /**
   * Check for Heartbleed vulnerability
   */
  async checkHeartbleed(target) {
    // Simplified check - in production, would send actual heartbeat request
    try {
      const sslInfo = await this.getSSLInfo(target);
      // Check OpenSSL version if available in server banner
      return false; // Placeholder
    } catch (error) {
      return false;
    }
  }

  /**
   * Check for DROWN vulnerability
   */
  async checkDROWN(target) {
    // Check if SSLv2 is supported
    try {
      // Simplified check
      return false; // Placeholder
    } catch (error) {
      return false;
    }
  }

  /**
   * Check for FREAK vulnerability
   */
  async checkFREAK(target) {
    // Check for export-grade cipher support
    return false; // Placeholder
  }

  /**
   * Check for Logjam vulnerability
   */
  async checkLogjam(target) {
    // Check for weak Diffie-Hellman parameters
    return false; // Placeholder
  }

  /**
   * Scan for service-specific vulnerabilities
   */
  async scanServiceVulnerabilities(target) {
    const vulnerabilities = [];

    try {
      // Attempt to fingerprint services and versions
      const services = await this.fingerprintServices(target);

      for (const service of services) {
        // Search CVE database for known vulnerabilities
        const cves = this.searchCVEs(service.name, service.version);

        cves.forEach(cve => {
          vulnerabilities.push({
            id: cve.id,
            type: 'service',
            severity: cve.severity,
            title: `${service.name} ${service.version}: ${cve.title}`,
            description: cve.description,
            service: service.name,
            version: service.version,
            port: service.port,
            cvssScore: cve.cvssScore,
            impact: cve.impact,
            recommendation: cve.recommendation,
            references: cve.references,
            exploitAvailable: cve.exploitAvailable
          });
        });

        // Check for end-of-life software
        if (this.isEndOfLife(service.name, service.version)) {
          vulnerabilities.push({
            id: `EOL-${service.name}`,
            type: 'service',
            severity: 'HIGH',
            title: `End-of-Life Software: ${service.name} ${service.version}`,
            description: `${service.name} ${service.version} is no longer supported`,
            service: service.name,
            version: service.version,
            impact: 'No security updates available, unpatched vulnerabilities',
            recommendation: `Upgrade ${service.name} to a supported version`
          });
        }
      }

    } catch (error) {
      console.error('Service vulnerability scan error:', error);
    }

    return vulnerabilities;
  }

  /**
   * Fingerprint services and their versions
   */
  async fingerprintServices(target) {
    const services = [];

    // Common service detection patterns
    const servicePorts = [
      { port: 22, name: 'OpenSSH', pattern: /OpenSSH[_\/]([\d.]+)/ },
      { port: 80, name: 'Apache', pattern: /Apache\/([\d.]+)/ },
      { port: 80, name: 'nginx', pattern: /nginx\/([\d.]+)/ },
      { port: 443, name: 'Apache', pattern: /Apache\/([\d.]+)/ },
      { port: 443, name: 'nginx', pattern: /nginx\/([\d.]+)/ },
      { port: 21, name: 'vsftpd', pattern: /vsftpd ([\d.]+)/ },
      { port: 25, name: 'Postfix', pattern: /Postfix/ },
      { port: 3306, name: 'MySQL', pattern: /MySQL ([\d.]+)/ },
      { port: 5432, name: 'PostgreSQL', pattern: /PostgreSQL ([\d.]+)/ }
    ];

    for (const servicePort of servicePorts) {
      try {
        const banner = await this.grabBanner(target, servicePort.port);
        if (banner) {
          const match = banner.match(servicePort.pattern);
          if (match) {
            services.push({
              name: servicePort.name,
              version: match[1] || 'unknown',
              port: servicePort.port,
              banner: banner
            });
          }
        }
      } catch (error) {
        // Service not available or banner grab failed
      }
    }

    return services;
  }

  /**
   * Grab service banner
   */
  async grabBanner(host, port, timeout = 3000) {
    return new Promise((resolve, reject) => {
      const socket = new net.Socket();
      let banner = '';

      socket.setTimeout(timeout);

      socket.on('data', (data) => {
        banner += data.toString();
      });

      socket.on('end', () => {
        resolve(banner);
      });

      socket.on('timeout', () => {
        socket.destroy();
        resolve(banner || null);
      });

      socket.on('error', (error) => {
        reject(error);
      });

      socket.connect(port, host, () => {
        // Some services send banner immediately, others need a request
        socket.write('\r\n');
      });

      // Wait a bit for banner
      setTimeout(() => {
        socket.end();
      }, timeout - 500);
    });
  }

  /**
   * Search CVE database for specific service and version
   */
  searchCVEs(serviceName, version) {
    if (!this.cveDatabase || !this.cveDatabase.cves) {
      return [];
    }

    return this.cveDatabase.cves.filter(cve => {
      const affectedProducts = cve.affectedProducts || [];
      return affectedProducts.some(product =>
        product.name.toLowerCase().includes(serviceName.toLowerCase()) &&
        this.versionInRange(version, product.versionRange)
      );
    });
  }

  /**
   * Search CVEs by service name only
   */
  searchCVEsByService(serviceName) {
    if (!this.cveDatabase || !this.cveDatabase.cves) {
      return [];
    }

    return this.cveDatabase.cves.filter(cve => {
      const affectedProducts = cve.affectedProducts || [];
      return affectedProducts.some(product =>
        product.name.toLowerCase().includes(serviceName.toLowerCase())
      );
    }).slice(0, 5); // Limit to 5 results
  }

  /**
   * Check if version is in vulnerable range
   */
  versionInRange(version, range) {
    if (!range) return false;
    // Simplified version comparison
    // In production, use semver or similar library
    return true;
  }

  /**
   * Check if software is end-of-life
   */
  isEndOfLife(serviceName, version) {
    const eolDatabase = {
      'OpenSSH': { eol: '7.0', date: '2015-08-11' },
      'Apache': { eol: '2.2', date: '2017-07-11' },
      'nginx': { eol: '1.10', date: '2017-04-04' },
      'MySQL': { eol: '5.5', date: '2018-12-31' },
      'PostgreSQL': { eol: '9.4', date: '2020-02-13' },
      'PHP': { eol: '7.2', date: '2020-11-30' },
      'Python': { eol: '2.7', date: '2020-01-01' }
    };

    const eolInfo = eolDatabase[serviceName];
    if (!eolInfo) return false;

    // Simplified version comparison
    return this.compareVersions(version, eolInfo.eol) <= 0;
  }

  /**
   * Compare version strings
   */
  compareVersions(v1, v2) {
    const parts1 = v1.split('.').map(Number);
    const parts2 = v2.split('.').map(Number);

    for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
      const part1 = parts1[i] || 0;
      const part2 = parts2[i] || 0;

      if (part1 > part2) return 1;
      if (part1 < part2) return -1;
    }

    return 0;
  }

  /**
   * Scan for web application vulnerabilities
   */
  async scanWebVulnerabilities(target) {
    const vulnerabilities = [];

    try {
      // Check HTTP security headers
      const headers = await this.checkSecurityHeaders(target);
      vulnerabilities.push(...headers);

      // Check for common web vulnerabilities
      const webVulns = await this.checkWebCommonVulnerabilities(target);
      vulnerabilities.push(...webVulns);

      // Check OWASP Top 10 indicators
      const owaspVulns = this.checkOWASPIndicators(target);
      vulnerabilities.push(...owaspVulns);

    } catch (error) {
      console.error('Web vulnerability scan error:', error);
    }

    return vulnerabilities;
  }

  /**
   * Check HTTP security headers
   */
  async checkSecurityHeaders(target) {
    const vulnerabilities = [];

    return new Promise((resolve) => {
      const options = {
        hostname: target,
        port: 443,
        path: '/',
        method: 'GET',
        rejectUnauthorized: false
      };

      const req = https.request(options, (res) => {
        const headers = res.headers;

        // Check for missing security headers
        const requiredHeaders = [
          {
            name: 'strict-transport-security',
            title: 'Missing HSTS Header',
            severity: 'MEDIUM',
            description: 'HTTP Strict Transport Security (HSTS) header not present',
            recommendation: 'Add Strict-Transport-Security header with appropriate max-age'
          },
          {
            name: 'x-frame-options',
            title: 'Missing X-Frame-Options Header',
            severity: 'MEDIUM',
            description: 'X-Frame-Options header not present, vulnerable to clickjacking',
            recommendation: 'Add X-Frame-Options: DENY or SAMEORIGIN'
          },
          {
            name: 'x-content-type-options',
            title: 'Missing X-Content-Type-Options Header',
            severity: 'LOW',
            description: 'X-Content-Type-Options header not present',
            recommendation: 'Add X-Content-Type-Options: nosniff'
          },
          {
            name: 'content-security-policy',
            title: 'Missing Content-Security-Policy Header',
            severity: 'HIGH',
            description: 'Content Security Policy not implemented',
            recommendation: 'Implement CSP to prevent XSS and injection attacks'
          },
          {
            name: 'x-xss-protection',
            title: 'Missing X-XSS-Protection Header',
            severity: 'LOW',
            description: 'X-XSS-Protection header not present',
            recommendation: 'Add X-XSS-Protection: 1; mode=block'
          }
        ];

        requiredHeaders.forEach((header, index) => {
          if (!headers[header.name]) {
            vulnerabilities.push({
              id: `WEB-HEADER-${index + 1}`,
              type: 'web',
              severity: header.severity,
              title: header.title,
              description: header.description,
              impact: 'Increased attack surface for various web attacks',
              recommendation: header.recommendation,
              references: [
                'https://owasp.org/www-project-secure-headers/',
                'https://securityheaders.com/'
              ]
            });
          }
        });

        resolve(vulnerabilities);
      });

      req.on('error', () => {
        resolve(vulnerabilities);
      });

      req.setTimeout(5000, () => {
        req.destroy();
        resolve(vulnerabilities);
      });

      req.end();
    });
  }

  /**
   * Check for common web vulnerabilities
   */
  async checkWebCommonVulnerabilities(target) {
    const vulnerabilities = [];

    // Check for common vulnerable paths
    const vulnerablePaths = [
      '/admin',
      '/.git',
      '/.env',
      '/phpinfo.php',
      '/wp-admin',
      '/backup',
      '/.htaccess',
      '/config.php'
    ];

    // This would be expanded in production
    // For now, add generic web vulnerabilities

    vulnerabilities.push({
      id: 'WEB-001',
      type: 'web',
      severity: 'INFO',
      title: 'Web Application Security Assessment Needed',
      description: 'Comprehensive web application testing recommended',
      recommendation: 'Perform OWASP ZAP or Burp Suite security scan',
      references: ['https://owasp.org/www-project-zap/']
    });

    return vulnerabilities;
  }

  /**
   * Check for OWASP Top 10 indicators
   */
  checkOWASPIndicators(target) {
    const vulnerabilities = [];

    // Add informational entries for OWASP Top 10
    Object.keys(this.owaspTop10).forEach((key, index) => {
      const owasp = this.owaspTop10[key];
      vulnerabilities.push({
        id: `OWASP-${key}`,
        type: 'owasp',
        severity: 'INFO',
        title: `OWASP ${key.replace('_', '-')}: ${owasp.name}`,
        description: owasp.description,
        indicators: owasp.indicators,
        cweIds: owasp.cweIds,
        recommendation: `Review application for ${owasp.name} vulnerabilities`,
        references: [
          'https://owasp.org/www-project-top-ten/',
          `https://owasp.org/Top10/${key.replace('_', '-')}/`
        ]
      });
    });

    return vulnerabilities;
  }

  /**
   * Scan for configuration vulnerabilities
   */
  async scanConfigurationVulnerabilities(target) {
    const vulnerabilities = [];

    try {
      // Check for default credentials
      vulnerabilities.push({
        id: 'CONFIG-001',
        type: 'configuration',
        severity: 'CRITICAL',
        title: 'Default Credentials Check Required',
        description: 'Services should be tested for default/weak credentials',
        impact: 'Unauthorized access, complete system compromise',
        recommendation: 'Test all services for default credentials and enforce strong password policy',
        references: [
          'https://github.com/danielmiessler/SecLists/tree/master/Passwords'
        ]
      });

      // Check for security misconfiguration
      vulnerabilities.push({
        id: 'CONFIG-002',
        type: 'configuration',
        severity: 'HIGH',
        title: 'Security Configuration Review Needed',
        description: 'System security configuration should be reviewed against CIS benchmarks',
        impact: 'Potential security weaknesses and misconfigurations',
        recommendation: 'Perform CIS benchmark assessment',
        references: [
          'https://www.cisecurity.org/cis-benchmarks/'
        ]
      });

    } catch (error) {
      console.error('Configuration scan error:', error);
    }

    return vulnerabilities;
  }

  /**
   * Check firewall configuration
   */
  async checkFirewallConfiguration(target) {
    // Placeholder for firewall checks
    return {
      id: 'FW-001',
      type: 'network',
      severity: 'INFO',
      title: 'Firewall Configuration Review',
      description: 'Firewall rules should be reviewed for security best practices',
      recommendation: 'Implement principle of least privilege for firewall rules',
      references: ['https://www.nist.gov/publications/guidelines-security-network-management']
    };
  }

  /**
   * Generate recommendations based on vulnerabilities found
   */
  generateRecommendations(vulnerabilities) {
    const recommendations = [];
    const priorityMap = { CRITICAL: 1, HIGH: 2, MEDIUM: 3, LOW: 4, INFO: 5 };

    // Sort by severity
    const sortedVulns = [...vulnerabilities].sort((a, b) =>
      priorityMap[a.severity] - priorityMap[b.severity]
    );

    // Generate top recommendations
    const criticalVulns = sortedVulns.filter(v => v.severity === 'CRITICAL');
    if (criticalVulns.length > 0) {
      recommendations.push({
        priority: 'IMMEDIATE',
        title: 'Address Critical Vulnerabilities',
        description: `${criticalVulns.length} critical vulnerabilities require immediate attention`,
        actions: criticalVulns.slice(0, 5).map(v => v.recommendation)
      });
    }

    const highVulns = sortedVulns.filter(v => v.severity === 'HIGH');
    if (highVulns.length > 0) {
      recommendations.push({
        priority: 'HIGH',
        title: 'Remediate High-Severity Issues',
        description: `${highVulns.length} high-severity vulnerabilities found`,
        actions: highVulns.slice(0, 5).map(v => v.recommendation)
      });
    }

    // General recommendations
    recommendations.push({
      priority: 'ONGOING',
      title: 'Implement Security Best Practices',
      actions: [
        'Enable automatic security updates',
        'Implement intrusion detection system',
        'Configure centralized logging and monitoring',
        'Perform regular vulnerability assessments',
        'Conduct security awareness training',
        'Implement defense-in-depth strategy'
      ]
    });

    return recommendations;
  }

  /**
   * Export scan results
   */
  exportResults(scanId, format = 'json') {
    const scan = this.scanResults.find(s => s.scanId === scanId);
    if (!scan) {
      throw new Error(`Scan ${scanId} not found`);
    }

    if (format === 'json') {
      return JSON.stringify(scan, null, 2);
    } else if (format === 'html') {
      return this.generateHTMLReport(scan);
    } else if (format === 'csv') {
      return this.generateCSVReport(scan);
    }

    throw new Error(`Unsupported format: ${format}`);
  }

  /**
   * Generate HTML report
   */
  generateHTMLReport(scan) {
    let html = `
<!DOCTYPE html>
<html>
<head>
    <title>Vulnerability Scan Report - ${scan.scanId}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1 { color: #333; }
        .critical { color: #d9534f; }
        .high { color: #f0ad4e; }
        .medium { color: #5bc0de; }
        .low { color: #5cb85c; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #333; color: white; }
    </style>
</head>
<body>
    <h1>Vulnerability Scan Report</h1>
    <p><strong>Scan ID:</strong> ${scan.scanId}</p>
    <p><strong>Target:</strong> ${scan.target}</p>
    <p><strong>Timestamp:</strong> ${scan.timestamp}</p>
    <p><strong>Duration:</strong> ${scan.duration}ms</p>

    <h2>Summary</h2>
    <ul>
        <li class="critical">Critical: ${scan.summary.critical}</li>
        <li class="high">High: ${scan.summary.high}</li>
        <li class="medium">Medium: ${scan.summary.medium}</li>
        <li class="low">Low: ${scan.summary.low}</li>
        <li>Info: ${scan.summary.info}</li>
    </ul>

    <h2>Vulnerabilities</h2>
    <table>
        <tr>
            <th>ID</th>
            <th>Severity</th>
            <th>Title</th>
            <th>Description</th>
            <th>Recommendation</th>
        </tr>`;

    scan.vulnerabilities.forEach(vuln => {
      html += `
        <tr>
            <td>${vuln.id}</td>
            <td class="${vuln.severity.toLowerCase()}">${vuln.severity}</td>
            <td>${vuln.title}</td>
            <td>${vuln.description}</td>
            <td>${vuln.recommendation || 'N/A'}</td>
        </tr>`;
    });

    html += `
    </table>
</body>
</html>`;

    return html;
  }

  /**
   * Generate CSV report
   */
  generateCSVReport(scan) {
    let csv = 'ID,Severity,Type,Title,Description,Recommendation\n';

    scan.vulnerabilities.forEach(vuln => {
      csv += `"${vuln.id}","${vuln.severity}","${vuln.type}","${vuln.title}","${vuln.description}","${vuln.recommendation || ''}"\n`;
    });

    return csv;
  }
}

module.exports = VulnerabilityScanner;
